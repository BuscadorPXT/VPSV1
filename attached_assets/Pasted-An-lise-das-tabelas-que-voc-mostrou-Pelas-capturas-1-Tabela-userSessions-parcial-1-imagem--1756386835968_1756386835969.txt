An√°lise das tabelas que voc√™ mostrou

Pelas capturas:
	1.	Tabela userSessions (parcial 1¬™ imagem)
	‚Ä¢	Possui id (serial) e userId (integer).
	‚Ä¢	N√£o h√° √≠ndice UNIQUE sobre userId.
	‚Ä¢	Isso explica por que o ON CONFLICT (userId) n√£o funciona ‚Üí n√£o existe restri√ß√£o para conflito.
	2.	Tabela userSessions (parcial 2¬™ imagem)
	‚Ä¢	Campos ip_address e lastActivity.
	‚Ä¢	Mostra que a tabela j√° tem v√°rias sess√µes criadas, mas todas do 127.0.0.1 ‚Üí provavelmente ambiente local.
	3.	Tabela userSessions (parcial 3¬™ imagem)
	‚Ä¢	Campos session_token (text) e expiresAt.
	‚Ä¢	Tokens est√£o sendo gerados, mas n√£o vinculados corretamente a um userId.
	4.	Erros de log que voc√™ enviou antes
	‚Ä¢	No session token found for user: jonathanpro@gmail.com.
	‚Ä¢	Isso confirma que o app n√£o consegue recuperar a sess√£o porque n√£o h√° chave √∫nica para gerenciar INSERT ... ON CONFLICT.

‚∏ª

‚úÖ Ajuste recomendado

Voc√™ precisa criar uma constraint √∫nica na tabela userSessions para que o ON CONFLICT funcione.
Assim, cada usu√°rio ter√° um √∫nico registro de sess√£o ativo (substitu√≠do em caso de novo login).

SQL sugerido:

-- Se cada usu√°rio s√≥ pode ter uma sess√£o v√°lida por vez
ALTER TABLE "userSessions"
ADD CONSTRAINT user_sessions_unique UNIQUE ("userId");

Se o design exigir m√∫ltiplas sess√µes por usu√°rio (ex.: login em celular e web ao mesmo tempo), ent√£o use session_token como chave √∫nica:

ALTER TABLE "userSessions"
ADD CONSTRAINT user_sessions_token_unique UNIQUE ("session_token");


‚∏ª

üöÄ Caminho seguro
	1.	Definir se um usu√°rio pode ter m√∫ltiplas sess√µes simult√¢neas ou apenas uma ativa.
	2.	Criar a constraint adequada (UNIQUE(userId) ou UNIQUE(session_token)).
	3.	Ajustar o INSERT ... ON CONFLICT no c√≥digo para bater com a constraint criada.
	‚Ä¢	Se UNIQUE(userId):

INSERT INTO "userSessions" ("userId", "session_token", "expiresAt", "ip_address", "lastActivity")
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT ("userId")
DO UPDATE SET "session_token" = EXCLUDED."session_token",
              "expiresAt" = EXCLUDED."expiresAt",
              "ip_address" = EXCLUDED."ip_address",
              "lastActivity" = EXCLUDED."lastActivity";


	‚Ä¢	Se UNIQUE(session_token), o c√≥digo de upsert deve usar ON CONFLICT (session_token).

‚∏ª

Recommendation: use UNIQUE(userId) se voc√™ quiser que cada usu√°rio tenha apenas uma sess√£o ativa por vez.
Next step: deseja que eu prepare o SQL completo para recriar a tabela userSessions com todas as colunas vistas nas imagens (id, userId, session_token, expiresAt, ip_address, lastActivity) j√° com a constraint correta?